<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Balance Beam Adventure</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #87CEEB;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #game-container {
            touch-action: none;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script>
// ============== BALANCE BEAM ADVENTURE - WEB VERSION ==============

const GAME_WIDTH = 800;
const GAME_HEIGHT = 500;

// iOS Audio Solution - Use HTML5 Audio with pre-loaded sounds
let bellAudio = null;
let audioInitialized = false;

// Create bell sound as base64 WAV (simple beep tone)
function createBellSound() {
    // Generate a simple bell tone WAV file
    const sampleRate = 22050;
    const duration = 0.3;
    const frequency = 880;
    const numSamples = Math.floor(sampleRate * duration);

    // WAV header
    const buffer = new ArrayBuffer(44 + numSamples * 2);
    const view = new DataView(buffer);

    // "RIFF" chunk descriptor
    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + numSamples * 2, true);
    writeString(view, 8, 'WAVE');

    // "fmt " sub-chunk
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true); // Subchunk1Size
    view.setUint16(20, 1, true); // AudioFormat (PCM)
    view.setUint16(22, 1, true); // NumChannels
    view.setUint32(24, sampleRate, true); // SampleRate
    view.setUint32(28, sampleRate * 2, true); // ByteRate
    view.setUint16(32, 2, true); // BlockAlign
    view.setUint16(34, 16, true); // BitsPerSample

    // "data" sub-chunk
    writeString(view, 36, 'data');
    view.setUint32(40, numSamples * 2, true);

    // Generate bell tone with decay
    for (let i = 0; i < numSamples; i++) {
        const t = i / sampleRate;
        const envelope = Math.exp(-t * 8); // Decay
        const sample = Math.sin(2 * Math.PI * frequency * t) * envelope * 0.8;
        view.setInt16(44 + i * 2, sample * 32767, true);
    }

    // Convert to base64
    const bytes = new Uint8Array(buffer);
    let binary = '';
    for (let i = 0; i < bytes.length; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return 'data:audio/wav;base64,' + btoa(binary);
}

function writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
    }
}

// Initialize audio on user interaction
function initAudio() {
    if (audioInitialized) return;

    try {
        // Create the bell audio element
        bellAudio = new Audio(createBellSound());
        bellAudio.volume = 0.7;

        // Play and immediately pause to unlock on iOS
        bellAudio.play().then(() => {
            bellAudio.pause();
            bellAudio.currentTime = 0;
            audioInitialized = true;
            console.log('Audio initialized for iOS');
        }).catch(e => {
            console.log('Audio init play failed, will retry on next tap');
        });
    } catch (e) {
        console.log('Audio init failed:', e);
    }
}

// Play bell sound
function playBell(times = 3) {
    if (!bellAudio) {
        bellAudio = new Audio(createBellSound());
        bellAudio.volume = 0.7;
    }

    let count = 0;
    function ring() {
        if (count < times) {
            bellAudio.currentTime = 0;
            bellAudio.play().catch(e => console.log('Bell play failed'));
            count++;
            setTimeout(ring, 200);
        }
    }
    ring();
}

// Add listeners to initialize audio on first interaction
['touchstart', 'touchend', 'click'].forEach(event => {
    document.addEventListener(event, initAudio, { once: false, passive: true });
});

// Colors
const COLORS = {
    SKY: 0x87CEEB,
    GRASS: 0x7CFC00,
    BEAM: 0x8B4513,
    BEAM_DARK: 0x654321,
    SKIN: 0xFFD5BD,
    LEOTARD: 0xFF69B4,
    HAIR: 0x654321,
    BALL: 0x1E3A5F,
    BEE_YELLOW: 0xFFD700,
    BEE_PINK: 0xFF69B4
};

// Game settings
const SETTINGS = {
    playerSpeed: 80,
    jumpForce: -350,
    gravity: 800,
    beamY: GAME_HEIGHT - 120,
    beamHeight: 15,
    floorY: GAME_HEIGHT - 50
};

// Level configurations
const LEVELS = [
    { ballSpeed: 120, ballInterval: 3000, beeInterval: 5000, ballCount: 2, beeCount: 1 },
    { ballSpeed: 140, ballInterval: 2500, beeInterval: 4500, ballCount: 3, beeCount: 2 },
    { ballSpeed: 160, ballInterval: 2200, beeInterval: 4000, ballCount: 3, beeCount: 2 },
    { ballSpeed: 180, ballInterval: 2000, beeInterval: 3500, ballCount: 4, beeCount: 3 },
    { ballSpeed: 200, ballInterval: 1800, beeInterval: 3000, ballCount: 4, beeCount: 4 }
];

// Player name storage
let playerName = 'Friend';

// ============== MENU SCENE ==============
class MenuScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MenuScene' });
        this.nameInput = null;
    }

    create() {
        // Sky background
        this.add.rectangle(GAME_WIDTH/2, GAME_HEIGHT/2, GAME_WIDTH, GAME_HEIGHT, COLORS.SKY);

        // Sun
        this.add.circle(GAME_WIDTH - 80, 60, 40, 0xFFFF00);

        // Grass
        this.add.rectangle(GAME_WIDTH/2, GAME_HEIGHT - 40, GAME_WIDTH, 80, COLORS.GRASS);

        // Title
        this.add.text(GAME_WIDTH/2, 80, 'Balance Beam', {
            fontSize: '48px',
            fontWeight: 'bold',
            color: '#333'
        }).setOrigin(0.5);

        this.add.text(GAME_WIDTH/2, 130, 'Adventure', {
            fontSize: '42px',
            fontWeight: 'bold',
            color: '#FF6600'
        }).setOrigin(0.5);

        // Name input label
        this.add.text(GAME_WIDTH/2, 190, 'Enter Your Name:', {
            fontSize: '22px',
            color: '#333'
        }).setOrigin(0.5);

        // Create HTML input for name
        this.createNameInput();

        // Play button
        const playBtn = this.add.rectangle(GAME_WIDTH/2, 320, 200, 60, 0x4CAF50)
            .setInteractive({ useHandCursor: true });
        this.add.text(GAME_WIDTH/2, 320, 'PLAY', {
            fontSize: '32px',
            fontWeight: 'bold',
            color: '#FFF'
        }).setOrigin(0.5);

        playBtn.on('pointerdown', () => {
            // Save the name
            if (this.nameInput && this.nameInput.value.trim()) {
                playerName = this.nameInput.value.trim();
            }
            this.removeNameInput();
            this.showWelcomeGreeting();
        });

        playBtn.on('pointerover', () => playBtn.setFillStyle(0x45a049));
        playBtn.on('pointerout', () => playBtn.setFillStyle(0x4CAF50));

        // Instructions
        this.add.text(GAME_WIDTH/2, 400, 'Tap or Press SPACE to Jump!', {
            fontSize: '20px',
            color: '#333'
        }).setOrigin(0.5);

        this.add.text(GAME_WIDTH/2, 435, 'Avoid bowling balls and bees!', {
            fontSize: '18px',
            color: '#666'
        }).setOrigin(0.5);
    }

    createNameInput() {
        // Create HTML input element
        this.nameInput = document.createElement('input');
        this.nameInput.type = 'text';
        this.nameInput.placeholder = 'Your name';
        this.nameInput.value = playerName !== 'Friend' ? playerName : '';
        this.nameInput.maxLength = 15;
        this.nameInput.style.cssText = `
            position: absolute;
            width: 200px;
            padding: 10px 15px;
            font-size: 18px;
            border: 3px solid #4CAF50;
            border-radius: 25px;
            text-align: center;
            outline: none;
            font-family: Arial, sans-serif;
        `;

        // Position the input over the canvas
        const canvas = document.querySelector('canvas');
        const rect = canvas.getBoundingClientRect();
        const scaleX = rect.width / GAME_WIDTH;
        const scaleY = rect.height / GAME_HEIGHT;

        this.nameInput.style.left = (rect.left + (GAME_WIDTH/2 - 100) * scaleX) + 'px';
        this.nameInput.style.top = (rect.top + 220 * scaleY) + 'px';
        this.nameInput.style.transform = `scale(${scaleX})`;
        this.nameInput.style.transformOrigin = 'top left';

        document.body.appendChild(this.nameInput);
    }

    removeNameInput() {
        if (this.nameInput && this.nameInput.parentNode) {
            this.nameInput.parentNode.removeChild(this.nameInput);
            this.nameInput = null;
        }
    }

    showWelcomeGreeting() {
        // Overlay
        const overlay = this.add.rectangle(GAME_WIDTH/2, GAME_HEIGHT/2, GAME_WIDTH, GAME_HEIGHT, 0x87CEEB);

        // Welcome message in English
        const welcomeEn = this.add.text(GAME_WIDTH/2, GAME_HEIGHT/2 - 60, `Welcome, ${playerName}!`, {
            fontSize: '38px',
            fontWeight: 'bold',
            color: '#333'
        }).setOrigin(0.5);

        // Welcome message in Swedish
        const welcomeSe = this.add.text(GAME_WIDTH/2, GAME_HEIGHT/2 + 10, `VÃ¤lkommen, ${playerName}!`, {
            fontSize: '34px',
            fontWeight: 'bold',
            color: '#FF6600'
        }).setOrigin(0.5);

        // Decorative stars
        const star1 = this.add.star(150, GAME_HEIGHT/2 - 30, 5, 15, 30, 0xFFD700);
        const star2 = this.add.star(GAME_WIDTH - 150, GAME_HEIGHT/2 - 30, 5, 15, 30, 0xFFD700);

        // Animate stars
        this.tweens.add({
            targets: [star1, star2],
            rotation: Math.PI * 2,
            duration: 2000,
            repeat: -1
        });

        // "Get Ready!" text
        const readyText = this.add.text(GAME_WIDTH/2, GAME_HEIGHT/2 + 80, 'Get Ready! / GÃ¶r dig redo!', {
            fontSize: '22px',
            color: '#666'
        }).setOrigin(0.5);

        // Fade in and then transition to game
        this.tweens.add({
            targets: [welcomeEn, welcomeSe, readyText],
            alpha: { from: 0, to: 1 },
            duration: 500,
            onComplete: () => {
                // Wait 2 seconds then start game
                this.time.delayedCall(2000, () => {
                    this.scene.start('GameScene', { level: 1, score: 0, lives: 3 });
                });
            }
        });
    }
}

// ============== GAME SCENE ==============
class GameScene extends Phaser.Scene {
    constructor() {
        super({ key: 'GameScene' });
    }

    init(data) {
        this.currentLevel = data.level || 1;
        this.score = data.score || 0;
        this.lives = data.lives || 3;
        this.levelConfig = LEVELS[this.currentLevel - 1];
        this.ballsSpawned = 0;
        this.beesSpawned = 0;
        this.isPlaying = true;
        this.isInvincible = false;
        this.facingFront = false;
        this.frontTimer = 0;

        // Floor routine states
        this.isFlipping = false;
        this.isFlippingDown = false;
        this.isFloorExercise = false;
        this.isFlippingUp = false;
        this.isPausing = false;
        this.flipAngle = 0;
        this.flipCount = 0;
        this.pauseTimer = 0;
        this.cartwheelAngle = 0;
    }

    create() {
        // Background
        this.add.rectangle(GAME_WIDTH/2, GAME_HEIGHT/2, GAME_WIDTH, GAME_HEIGHT, COLORS.SKY);

        // Sun
        this.add.circle(GAME_WIDTH - 80, 60, 35, 0xFFFF00);

        // Clouds
        this.createCloud(100, 80);
        this.createCloud(350, 60);
        this.createCloud(600, 90);

        // Grass
        this.add.rectangle(GAME_WIDTH/2, GAME_HEIGHT - 30, GAME_WIDTH, 60, COLORS.GRASS);

        // Balance beam
        this.beamLeft = 50;
        this.beamRight = GAME_WIDTH - 50;
        this.beamTop = SETTINGS.beamY;

        this.add.rectangle(GAME_WIDTH/2, this.beamTop + SETTINGS.beamHeight/2,
            this.beamRight - this.beamLeft, SETTINGS.beamHeight, COLORS.BEAM);

        // Beam supports
        this.add.rectangle(this.beamLeft + 30, this.beamTop + 40, 15, 80, COLORS.BEAM_DARK);
        this.add.rectangle(this.beamRight - 30, this.beamTop + 40, 15, 80, COLORS.BEAM_DARK);

        // Finish flag
        this.add.rectangle(this.beamRight - 20, this.beamTop - 30, 5, 60, COLORS.BEAM_DARK);
        this.add.triangle(this.beamRight - 20, this.beamTop - 55, 0, 0, 0, 25, 30, 12, 0xFF0000);

        // Create player graphics
        this.createPlayer();

        // Obstacle groups
        this.balls = this.add.group();
        this.bees = this.add.group();

        // UI
        this.createUI();

        // Speech bubble (hidden initially)
        this.speechBubble = this.add.container(0, 0);
        this.speechBubble.setVisible(false);
        this.speechBubble.setDepth(100);

        // Input
        this.input.on('pointerdown', () => this.jump());
        this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

        // Spawn timers
        this.ballTimer = this.time.addEvent({
            delay: this.levelConfig.ballInterval,
            callback: this.spawnBall,
            callbackScope: this,
            loop: true
        });

        this.beeTimer = this.time.addEvent({
            delay: this.levelConfig.beeInterval,
            callback: this.spawnBee,
            callbackScope: this,
            loop: true
        });

        // Physics
        this.playerVelocityY = 0;
        this.isGrounded = true;
        this.legAngle = 0;
    }

    createCloud(x, y) {
        this.add.ellipse(x, y, 60, 30, 0xFFFFFF);
        this.add.ellipse(x + 25, y - 10, 50, 25, 0xFFFFFF);
        this.add.ellipse(x - 20, y + 5, 40, 20, 0xFFFFFF);
    }

    createPlayer() {
        this.player = this.add.container(this.beamLeft + 30, this.beamTop - 35);
        this.drawPlayerSide();
    }

    drawPlayerSide() {
        this.player.removeAll(true);

        const legSwing = Math.sin(this.legAngle) * 0.3;

        // Back leg
        const backLeg = this.add.rectangle(-3, 20, 6, 20, COLORS.SKIN).setOrigin(0.5, 0);
        backLeg.setRotation(-legSwing);
        backLeg.setAlpha(0.8);
        this.player.add(backLeg);

        // Front leg
        const frontLeg = this.add.rectangle(3, 20, 6, 20, COLORS.SKIN).setOrigin(0.5, 0);
        frontLeg.setRotation(legSwing);
        this.player.add(frontLeg);

        // Body (leotard)
        this.player.add(this.add.rectangle(0, 5, 16, 25, COLORS.LEOTARD));

        // Back arm
        const backArm = this.add.rectangle(-8, -2, 5, 16, COLORS.SKIN).setOrigin(0.5, 0);
        backArm.setRotation(legSwing + 0.3);
        backArm.setAlpha(0.8);
        this.player.add(backArm);

        // Front arm
        const frontArm = this.add.rectangle(8, -2, 5, 16, COLORS.SKIN).setOrigin(0.5, 0);
        frontArm.setRotation(-legSwing - 0.3);
        this.player.add(frontArm);

        // Head
        this.player.add(this.add.ellipse(0, -18, 18, 16, COLORS.HAIR)); // Hair back
        this.player.add(this.add.ellipse(2, -16, 14, 14, COLORS.SKIN)); // Face

        // Ponytail
        const pony = this.add.ellipse(-12, -15, 8, 18, COLORS.HAIR);
        pony.setRotation(-0.5 + Math.sin(this.legAngle * 1.5) * 0.2);
        this.player.add(pony);

        // Eye
        this.player.add(this.add.circle(6, -17, 3, 0xFFFFFF));
        this.player.add(this.add.circle(7, -17, 1.5, 0x000000));

        // Smile
        const smile = this.add.graphics();
        smile.lineStyle(1.5, 0x000000);
        smile.beginPath();
        smile.arc(4, -12, 4, 0, Math.PI * 0.7);
        smile.strokePath();
        this.player.add(smile);

        // Cheek
        this.player.add(this.add.ellipse(2, -12, 4, 3, 0xFFAAAA, 0.5));
    }

    drawPlayerFront() {
        this.player.removeAll(true);

        // Legs
        this.player.add(this.add.rectangle(-6, 22, 7, 22, COLORS.SKIN));
        this.player.add(this.add.rectangle(6, 22, 7, 22, COLORS.SKIN));

        // Body
        this.player.add(this.add.rectangle(0, 5, 18, 26, COLORS.LEOTARD));

        // Arms raised (V shape)
        const leftArm = this.add.rectangle(-12, -8, 5, 18, COLORS.SKIN).setOrigin(0.5, 1);
        leftArm.setRotation(-0.5);
        this.player.add(leftArm);

        const rightArm = this.add.rectangle(12, -8, 5, 18, COLORS.SKIN).setOrigin(0.5, 1);
        rightArm.setRotation(0.5);
        this.player.add(rightArm);

        // Head
        this.player.add(this.add.ellipse(0, -18, 20, 18, COLORS.HAIR));
        this.player.add(this.add.ellipse(0, -16, 16, 15, COLORS.SKIN));

        // Ponytail
        this.player.add(this.add.ellipse(0, -30, 8, 12, COLORS.HAIR));

        // Happy closed eyes
        const leftEye = this.add.graphics();
        leftEye.lineStyle(2, 0x000000);
        leftEye.arc(-4, -17, 3, Math.PI, 0);
        leftEye.strokePath();
        this.player.add(leftEye);

        const rightEye = this.add.graphics();
        rightEye.lineStyle(2, 0x000000);
        rightEye.arc(4, -17, 3, Math.PI, 0);
        rightEye.strokePath();
        this.player.add(rightEye);

        // Big smile
        const smile = this.add.graphics();
        smile.lineStyle(2, 0x000000);
        smile.arc(0, -10, 6, 0, Math.PI);
        smile.strokePath();
        this.player.add(smile);

        // Rosy cheeks
        this.player.add(this.add.ellipse(-8, -12, 5, 4, 0xFFAAAA, 0.6));
        this.player.add(this.add.ellipse(8, -12, 5, 4, 0xFFAAAA, 0.6));
    }

    drawPlayerFlipping() {
        this.player.removeAll(true);

        // Tucked body during flip
        // Legs tucked
        this.player.add(this.add.ellipse(-5, 8, 7, 14, COLORS.SKIN));
        this.player.add(this.add.ellipse(5, 8, 7, 14, COLORS.SKIN));

        // Body tucked
        this.player.add(this.add.ellipse(0, 0, 22, 26, COLORS.LEOTARD));

        // Arms wrapped
        this.player.add(this.add.ellipse(-10, 2, 5, 16, COLORS.SKIN));
        this.player.add(this.add.ellipse(10, 2, 5, 16, COLORS.SKIN));

        // Head
        this.player.add(this.add.ellipse(0, -16, 20, 18, COLORS.HAIR));
        this.player.add(this.add.ellipse(0, -14, 16, 14, COLORS.SKIN));

        // Ponytail flying
        const pony = this.add.ellipse(0, -28, 8, 14, COLORS.HAIR);
        pony.setRotation(this.flipAngle * 0.01);
        this.player.add(pony);

        // Determined eyes
        this.player.add(this.add.circle(-4, -15, 2, 0x000000));
        this.player.add(this.add.circle(4, -15, 2, 0x000000));
    }

    drawPlayerCartwheel() {
        this.player.removeAll(true);

        // Extended body for cartwheel
        // Legs spread
        const leg1 = this.add.rectangle(0, 18, 7, 26, COLORS.SKIN).setOrigin(0.5, 0);
        leg1.setRotation(0.4);
        this.player.add(leg1);

        const leg2 = this.add.rectangle(0, -5, 7, 26, COLORS.SKIN).setOrigin(0.5, 1);
        leg2.setRotation(-0.4);
        this.player.add(leg2);

        // Body stretched
        this.player.add(this.add.rectangle(0, 5, 18, 28, COLORS.LEOTARD));

        // Arms spread
        const arm1 = this.add.rectangle(-10, 0, 5, 20, COLORS.SKIN).setOrigin(0.5, 0);
        arm1.setRotation(0.6);
        this.player.add(arm1);

        const arm2 = this.add.rectangle(10, 0, 5, 20, COLORS.SKIN).setOrigin(0.5, 0);
        arm2.setRotation(-0.6);
        this.player.add(arm2);

        // Head
        this.player.add(this.add.ellipse(0, -18, 18, 16, COLORS.HAIR));
        this.player.add(this.add.ellipse(0, -16, 14, 13, COLORS.SKIN));

        // Ponytail
        const pony = this.add.ellipse(0, -28, 6, 12, COLORS.HAIR);
        pony.setRotation(this.cartwheelAngle * 0.005);
        this.player.add(pony);

        // Eyes
        this.player.add(this.add.circle(-3, -16, 2, 0x000000));
        this.player.add(this.add.circle(3, -16, 2, 0x000000));
    }

    createUI() {
        this.levelText = this.add.text(GAME_WIDTH/2, 20, `Level ${this.currentLevel}`, {
            fontSize: '24px',
            fontWeight: 'bold',
            color: '#333'
        }).setOrigin(0.5, 0);

        this.scoreText = this.add.text(20, 20, `Score: ${this.score}`, {
            fontSize: '20px',
            color: '#333'
        });

        this.livesText = this.add.text(GAME_WIDTH - 20, 20, `Lives: ${'â¤ï¸'.repeat(this.lives)}`, {
            fontSize: '20px',
            color: '#333'
        }).setOrigin(1, 0);
    }

    jump() {
        if (this.isGrounded && this.isPlaying && !this.isFlipping && !this.isFloorExercise) {
            // Check if obstacles are close - need super jump
            const needsSuperJump = this.checkObstaclesClose();

            if (needsSuperJump) {
                // Super high jump (50% higher)
                this.playerVelocityY = SETTINGS.jumpForce * 1.5;
            } else {
                this.playerVelocityY = SETTINGS.jumpForce;
            }
            this.isGrounded = false;
        }
    }

    checkObstaclesClose() {
        // Check if both a ball and bee are within danger range
        const dangerRange = 200; // pixels ahead
        let ballClose = false;
        let beeClose = false;

        this.balls.getChildren().forEach(ball => {
            const dist = ball.x - this.player.x;
            if (dist > 0 && dist < dangerRange) {
                ballClose = true;
            }
        });

        this.bees.getChildren().forEach(bee => {
            const dist = bee.x - this.player.x;
            if (dist > 0 && dist < dangerRange) {
                beeClose = true;
            }
        });

        // Need super jump if both are close, or if any obstacle is very close
        const veryCloseRange = 100;
        let anyVeryClose = false;

        this.balls.getChildren().forEach(ball => {
            const dist = ball.x - this.player.x;
            if (dist > 0 && dist < veryCloseRange) {
                anyVeryClose = true;
            }
        });

        this.bees.getChildren().forEach(bee => {
            const dist = bee.x - this.player.x;
            if (dist > 0 && dist < veryCloseRange) {
                anyVeryClose = true;
            }
        });

        return (ballClose && beeClose) || anyVeryClose;
    }

    spawnBall() {
        if (!this.isPlaying || this.ballsSpawned >= this.levelConfig.ballCount) return;

        const ball = this.add.container(GAME_WIDTH + 30, this.beamTop - 15);

        // Ball body
        ball.add(this.add.circle(0, 0, 18, COLORS.BALL));
        // Finger holes
        ball.add(this.add.circle(0, -8, 4, 0xFFFFFF));
        ball.add(this.add.circle(-6, 2, 4, 0xFFFFFF));
        ball.add(this.add.circle(6, 2, 4, 0xFFFFFF));
        // Shine
        ball.add(this.add.circle(-6, -8, 4, 0xFFFFFF, 0.3));

        ball.speed = this.levelConfig.ballSpeed;
        ball.rotation = 0;
        this.balls.add(ball);
        this.ballsSpawned++;
    }

    spawnBee() {
        if (!this.isPlaying || this.beesSpawned >= this.levelConfig.beeCount) return;

        const beeY = Phaser.Math.Between(this.beamTop - 100, this.beamTop - 50);
        const bee = this.add.container(GAME_WIDTH + 30, beeY);

        // Wings (pink!)
        bee.add(this.add.ellipse(-10, -8, 16, 10, COLORS.BEE_PINK, 0.7));
        bee.add(this.add.ellipse(10, -8, 16, 10, COLORS.BEE_PINK, 0.7));

        // Body
        bee.add(this.add.ellipse(0, 0, 28, 18, COLORS.BEE_YELLOW));

        // Stripes
        bee.add(this.add.rectangle(-4, 0, 4, 16, 0x000000));
        bee.add(this.add.rectangle(4, 0, 4, 16, 0x000000));

        // Eyes
        bee.add(this.add.circle(10, -2, 3, 0x000000));

        bee.speed = 150;
        bee.startY = beeY;
        bee.bobOffset = 0;
        bee.wingAngle = 0;
        this.bees.add(bee);
        this.beesSpawned++;
    }

    update(time, delta) {
        const dt = delta / 1000;

        // Handle floor routine animations
        if (this.isFlippingDown) {
            this.updateFlipDown(dt);
            return;
        }

        if (this.isFloorExercise) {
            this.updateFloorExercise(dt);
            return;
        }

        if (this.isFlippingUp) {
            this.updateFlipUp(dt);
            return;
        }

        if (!this.isPlaying) return;

        // Space key
        if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {
            this.jump();
        }

        // Player movement
        this.player.x += SETTINGS.playerSpeed * dt;

        // Handle facing front timer
        if (this.facingFront) {
            this.frontTimer -= dt;
            if (this.frontTimer <= 0) {
                this.facingFront = false;
            }
        }

        // Gravity
        if (!this.isGrounded) {
            this.playerVelocityY += SETTINGS.gravity * dt;
            this.player.y += this.playerVelocityY * dt;

            if (this.player.y >= this.beamTop - 35) {
                this.player.y = this.beamTop - 35;
                this.playerVelocityY = 0;
                const wasInAir = !this.isGrounded;
                this.isGrounded = true;

                // Turn to face player after landing
                if (wasInAir) {
                    this.facingFront = true;
                    this.frontTimer = 0.4;
                    // Say hi to the player!
                    this.showSpeechBubble(`Hi ${playerName}!`, 800, '#FF69B4');
                }
            }
        }

        // Walking animation
        if (this.isGrounded && !this.facingFront) {
            this.legAngle += dt * 10;
            this.drawPlayerSide();
        } else if (this.facingFront) {
            this.drawPlayerFront();
        }

        // Invincibility flash
        if (this.isInvincible) {
            this.player.setAlpha(Math.sin(time * 0.02) > 0 ? 1 : 0.3);
        }

        // Check win
        if (this.player.x >= this.beamRight - 30) {
            this.startFloorRoutine();
            return;
        }

        // Update balls
        this.balls.getChildren().forEach(ball => {
            ball.x -= ball.speed * dt;
            ball.rotation -= dt * 3;
            ball.list[0].setRotation(ball.rotation);

            if (ball.x < -50) {
                ball.destroy();
            } else if (!this.isInvincible && this.checkCollision(ball, 18)) {
                this.playerHit();
            }
        });

        // Update bees
        this.bees.getChildren().forEach(bee => {
            bee.x -= bee.speed * dt;
            bee.bobOffset += dt * 3;
            bee.y = bee.startY + Math.sin(bee.bobOffset) * 15;

            // Wing animation
            bee.wingAngle += dt * 25;
            const wingScale = 0.7 + Math.abs(Math.sin(bee.wingAngle)) * 0.5;
            bee.list[0].setScale(1, wingScale);
            bee.list[1].setScale(1, wingScale);

            if (bee.x < -50) {
                bee.destroy();
            } else if (!this.isInvincible && this.checkCollision(bee, 15)) {
                this.playerHit();
            }
        });
    }

    // ============== FLOOR ROUTINE ==============
    startFloorRoutine() {
        this.isPlaying = false;
        this.ballTimer.remove();
        this.beeTimer.remove();

        // Clear obstacles
        this.balls.clear(true, true);
        this.bees.clear(true, true);

        // Start flip down
        this.isFlippingDown = true;
        this.flipAngle = 0;
        this.flipPhase = 0;
        this.flipStartY = this.player.y;
    }

    updateFlipDown(dt) {
        this.flipAngle += dt * 720; // Fast rotation
        this.player.setRotation(Phaser.Math.DegToRad(this.flipAngle));

        // Move down to floor
        const targetY = SETTINGS.floorY - 35;
        this.player.y += (targetY - this.player.y) * dt * 3;

        this.drawPlayerFlipping();

        if (this.flipAngle >= 360) {
            this.player.setRotation(0);
            this.player.y = targetY;
            this.isFlippingDown = false;

            // Start floor exercise
            this.isFloorExercise = true;
            this.flipCount = 0;
            this.cartwheelAngle = 0;
            this.isPausing = false;
            this.pauseTimer = 0;
        }
    }

    updateFloorExercise(dt) {
        // Handle pause
        if (this.isPausing) {
            this.pauseTimer -= dt;
            this.drawPlayerFront(); // Stand facing player during pause
            this.player.setRotation(0);

            if (this.pauseTimer <= 0) {
                this.isPausing = false;
                this.flipCount = 0;
            }
            return;
        }

        // Move left while doing cartwheels
        const speed = 200;
        this.player.x -= speed * dt;
        this.cartwheelAngle += dt * 400;

        // Rotate the whole container
        this.player.setRotation(Phaser.Math.DegToRad(this.cartwheelAngle));
        this.drawPlayerCartwheel();

        // Count flips
        if (this.cartwheelAngle >= 360) {
            this.cartwheelAngle -= 360;
            this.flipCount++;

            // Pause after every 3 flips
            if (this.flipCount >= 3) {
                this.isPausing = true;
                this.pauseTimer = 0.5;
                this.player.setRotation(0);
            }
        }

        // Check if reached start
        if (this.player.x <= this.beamLeft + 30) {
            this.player.x = this.beamLeft + 30;
            this.player.setRotation(0);
            this.isFloorExercise = false;

            // Start flip up
            this.isFlippingUp = true;
            this.flipAngle = 0;
            this.flipStartY = this.player.y;
        }
    }

    updateFlipUp(dt) {
        this.flipAngle += dt * 540;

        // Arc motion up to beam
        const progress = Math.min(this.flipAngle / 360, 1);
        const targetY = this.beamTop - 35;
        const arcHeight = 80;
        const arc = Math.sin(progress * Math.PI) * arcHeight;

        this.player.y = this.flipStartY + (targetY - this.flipStartY) * progress - arc;
        this.player.setRotation(Phaser.Math.DegToRad(this.flipAngle));

        this.drawPlayerFlipping();

        if (this.flipAngle >= 360) {
            this.player.setRotation(0);
            this.player.y = targetY;
            this.isFlippingUp = false;

            // Face player and celebrate
            this.facingFront = true;
            this.drawPlayerFront();

            // Now complete the level
            this.time.delayedCall(500, () => {
                this.levelComplete();
            });
        }
    }

    checkCollision(obstacle, radius) {
        const dx = this.player.x - obstacle.x;
        const dy = this.player.y - obstacle.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        return dist < radius + 15;
    }

    playerHit() {
        this.lives--;
        this.livesText.setText(`Lives: ${'â¤ï¸'.repeat(Math.max(0, this.lives))}${'ðŸ–¤'.repeat(3 - Math.max(0, this.lives))}`);

        // Show "Noooo!" when hit
        this.showSpeechBubble('Noooo!', 1000, '#FF0000');

        if (this.lives <= 0) {
            this.gameOver();
        } else {
            this.isInvincible = true;
            this.time.delayedCall(1500, () => {
                this.isInvincible = false;
                this.player.setAlpha(1);
            });
            this.resetPlayer();
        }
    }

    resetPlayer() {
        this.player.x = this.beamLeft + 30;
        this.player.y = this.beamTop - 35;
        this.playerVelocityY = 0;
        this.isGrounded = true;

        // Clear obstacles
        this.balls.clear(true, true);
        this.bees.clear(true, true);
        this.ballsSpawned = 0;
        this.beesSpawned = 0;
    }

    levelComplete() {
        this.score += 100;

        // Show "Hooray!" speech bubble
        this.showSpeechBubble('Hooray!', 1500, '#4CAF50');

        // Play bell sound
        this.playBellSound();

        // Show confetti
        this.createConfetti();

        // Show message
        this.time.delayedCall(300, () => {
            const overlay = this.add.rectangle(GAME_WIDTH/2, GAME_HEIGHT/2, GAME_WIDTH, GAME_HEIGHT, 0x000000, 0.5);

            let title, btnText;
            if (this.currentLevel >= 5) {
                title = 'YOU WON!';
                btnText = 'Play Again';
            } else {
                title = 'Level Complete!';
                btnText = 'Next Level';
            }

            this.add.text(GAME_WIDTH/2, GAME_HEIGHT/2 - 60, title, {
                fontSize: '36px',
                fontWeight: 'bold',
                color: '#FFF'
            }).setOrigin(0.5);

            this.add.text(GAME_WIDTH/2, GAME_HEIGHT/2 - 20, `+100 Points!`, {
                fontSize: '24px',
                color: '#FFD700'
            }).setOrigin(0.5);

            this.add.text(GAME_WIDTH/2, GAME_HEIGHT/2 + 10, `Score: ${this.score}`, {
                fontSize: '22px',
                color: '#FFF'
            }).setOrigin(0.5);

            const btn = this.add.rectangle(GAME_WIDTH/2, GAME_HEIGHT/2 + 70, 180, 50, 0x4CAF50)
                .setInteractive({ useHandCursor: true });
            this.add.text(GAME_WIDTH/2, GAME_HEIGHT/2 + 70, btnText, {
                fontSize: '24px',
                fontWeight: 'bold',
                color: '#FFF'
            }).setOrigin(0.5);

            btn.on('pointerdown', () => {
                if (this.currentLevel >= 5) {
                    this.scene.start('GameScene', { level: 1, score: 0, lives: 3 });
                } else {
                    this.scene.start('GameScene', { level: this.currentLevel + 1, score: this.score, lives: this.lives });
                }
            });
        });
    }

    gameOver() {
        this.isPlaying = false;
        this.ballTimer.remove();
        this.beeTimer.remove();

        const overlay = this.add.rectangle(GAME_WIDTH/2, GAME_HEIGHT/2, GAME_WIDTH, GAME_HEIGHT, 0x000000, 0.6);

        this.add.text(GAME_WIDTH/2, GAME_HEIGHT/2 - 60, 'Game Over', {
            fontSize: '40px',
            fontWeight: 'bold',
            color: '#FF4444'
        }).setOrigin(0.5);

        this.add.text(GAME_WIDTH/2, GAME_HEIGHT/2, `Score: ${this.score}`, {
            fontSize: '28px',
            color: '#FFF'
        }).setOrigin(0.5);

        const btn = this.add.rectangle(GAME_WIDTH/2, GAME_HEIGHT/2 + 70, 180, 50, 0x4CAF50)
            .setInteractive({ useHandCursor: true });
        this.add.text(GAME_WIDTH/2, GAME_HEIGHT/2 + 70, 'Try Again', {
            fontSize: '24px',
            fontWeight: 'bold',
            color: '#FFF'
        }).setOrigin(0.5);

        btn.on('pointerdown', () => {
            this.scene.start('GameScene', { level: this.currentLevel, score: 0, lives: 3 });
        });
    }

    createConfetti() {
        for (let i = 0; i < 50; i++) {
            const x = Phaser.Math.Between(50, GAME_WIDTH - 50);
            const colors = [0xFF69B4, 0xFFD700, 0x4CAF50, 0x2196F3, 0xFF5722, 0x9C27B0];
            const color = colors[Phaser.Math.Between(0, colors.length - 1)];

            const confetti = this.add.rectangle(x, -20, 10, 10, color);

            this.tweens.add({
                targets: confetti,
                y: GAME_HEIGHT + 20,
                x: x + Phaser.Math.Between(-100, 100),
                rotation: Phaser.Math.Between(0, 10),
                duration: Phaser.Math.Between(2000, 3500),
                ease: 'Linear'
            });
        }

        // Medals
        for (let i = 0; i < 8; i++) {
            const x = Phaser.Math.Between(100, GAME_WIDTH - 100);
            const medal = this.add.container(x, -30);

            // Ribbon
            medal.add(this.add.rectangle(0, -15, 8, 20, 0xCC0000));
            // Medal circle
            medal.add(this.add.circle(0, 5, 15, 0xFFD700));
            // Star
            medal.add(this.add.star(0, 5, 5, 5, 10, 0xFFFF00));

            this.tweens.add({
                targets: medal,
                y: GAME_HEIGHT + 50,
                rotation: Phaser.Math.Between(-2, 2),
                duration: Phaser.Math.Between(2500, 4000),
                ease: 'Linear'
            });
        }
    }

    playBellSound() {
        // Use HTML5 Audio for iOS compatibility
        const numRings = Math.min(3 + this.currentLevel, 8);
        playBell(numRings);
    }

    showSpeechBubble(message, duration = 1000, color = '#333') {
        // Clear previous speech bubble
        this.speechBubble.removeAll(true);

        // Position above player
        const bubbleX = this.player.x;
        const bubbleY = this.player.y - 80;

        // Create bubble background
        const padding = 12;
        const textObj = this.add.text(0, 0, message, {
            fontSize: '18px',
            fontWeight: 'bold',
            color: color
        }).setOrigin(0.5);

        const bubbleWidth = textObj.width + padding * 2;
        const bubbleHeight = textObj.height + padding * 2;

        const bg = this.add.graphics();
        bg.fillStyle(0xFFFFFF, 0.95);
        bg.lineStyle(3, 0x333333);
        bg.fillRoundedRect(-bubbleWidth/2, -bubbleHeight/2, bubbleWidth, bubbleHeight, 10);
        bg.strokeRoundedRect(-bubbleWidth/2, -bubbleHeight/2, bubbleWidth, bubbleHeight, 10);

        // Speech bubble pointer
        bg.fillStyle(0xFFFFFF, 0.95);
        bg.fillTriangle(-8, bubbleHeight/2, 8, bubbleHeight/2, 0, bubbleHeight/2 + 12);
        bg.lineStyle(3, 0x333333);
        bg.lineBetween(-8, bubbleHeight/2, 0, bubbleHeight/2 + 12);
        bg.lineBetween(8, bubbleHeight/2, 0, bubbleHeight/2 + 12);

        this.speechBubble.add(bg);
        this.speechBubble.add(textObj);
        this.speechBubble.setPosition(bubbleX, bubbleY);
        this.speechBubble.setVisible(true);

        // Auto-hide after duration
        this.time.delayedCall(duration, () => {
            this.speechBubble.setVisible(false);
        });
    }
}

// ============== GAME CONFIG ==============
const config = {
    type: Phaser.AUTO,
    width: GAME_WIDTH,
    height: GAME_HEIGHT,
    parent: 'game-container',
    backgroundColor: COLORS.SKY,
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
    },
    scene: [MenuScene, GameScene]
};

const game = new Phaser.Game(config);
    </script>
</body>
</html>
